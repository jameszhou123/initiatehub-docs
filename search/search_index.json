{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the InitiateHub Documentation Find guides and references for projects at InitiateHub, including mobile apps, websites, and development workflows. \ud83d\udcda Contents Flutter Development Project Structure New Project with Firebase Strapi Deploy Guide Projects Encyclopedia Mobile App Project Overview Features Wall \ud83d\ude80 Getting Started Start with the Flutter Development section or explore specific projects. \ud83d\udce2 Contribute Keep our docs updated! Contact the documentation team with suggestions.","title":"Home"},{"location":"#welcome-to-the-initiatehub-documentation","text":"Find guides and references for projects at InitiateHub, including mobile apps, websites, and development workflows.","title":"Welcome to the InitiateHub Documentation"},{"location":"#contents","text":"","title":"\ud83d\udcda Contents"},{"location":"#flutter-development","text":"Project Structure New Project with Firebase","title":"Flutter Development"},{"location":"#strapi","text":"Deploy Guide","title":"Strapi"},{"location":"#projects","text":"","title":"Projects"},{"location":"#encyclopedia-mobile-app","text":"Project Overview Features Wall","title":"Encyclopedia Mobile App"},{"location":"#getting-started","text":"Start with the Flutter Development section or explore specific projects.","title":"\ud83d\ude80 Getting Started"},{"location":"#contribute","text":"Keep our docs updated! Contact the documentation team with suggestions.","title":"\ud83d\udce2 Contribute"},{"location":"flutter/new-project-with-firebase/","text":"Firebase Setup Guide for Flutter Projects 1. Create New Project flutter create --org com.initiatehub --platforms android,ios,web encyclopedia Tip: Always use --org and --platforms when creating a new project. 2. Firebase Configuration Run flutterfire configure to create a new project on Firebase. Add Firebase plugins: bash flutter pub add firebase_plugin_name1 firebase_plugin_name2 ... Run flutterfire configure again after adding all plugins. 3. Android Setup Update app/build.gradle Add these dependencies: dependencies { // Import the Firebase BoM implementation platform('com.google.firebase:firebase-bom:33.2.0') // Add the dependencies for Firebase products implementation 'com.google.firebase:firebase-auth' implementation 'com.google.firebase:firebase-firestore' implementation 'com.google.firebase:firebase-storage' implementation 'com.google.firebase:firebase-analytics' // For Google Sign-In implementation 'com.google.android.gms:play-services-auth:20.7.0' // Add other Firebase products as needed } Sync the gradle in Android Studio after adding dependencies. 4. Firebase Console Setup Enable password signin and Google sign-in providers. Add SHA1 and SHA256 keys for Google Sign-In. Generate Release Keystore In the android folder, run: keytool -genkey -v -keystore encyclopedia-release-key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias encyclopedia Configure Release Keystore In app/build.gradle: android { ... signingConfigs { release { keyAlias 'com.initiatehub.encyclopedia' keyPassword 'your-key-password' storeFile file('encyclopedia-release-key.jks') storePassword 'your-keystore-password' } } buildTypes { release { signingConfig signingConfigs.release minifyEnabled false shrinkResources false } } } Get Signing Report Run in the android folder: ./gradlew signingReport Add both debug and release SHA1 and SHA256 to Firebase console project settings. 5. Final Steps Run flutterfire configure again to pull all Firebase config changes. Copy all auth feature code to the new project. Note: If prompted to upgrade Kotlin version during gradle sync, follow the system instructions.","title":"New Project with Firebase"},{"location":"flutter/new-project-with-firebase/#firebase-setup-guide-for-flutter-projects","text":"","title":"Firebase Setup Guide for Flutter Projects"},{"location":"flutter/new-project-with-firebase/#1-create-new-project","text":"flutter create --org com.initiatehub --platforms android,ios,web encyclopedia Tip: Always use --org and --platforms when creating a new project.","title":"1. Create New Project"},{"location":"flutter/new-project-with-firebase/#2-firebase-configuration","text":"Run flutterfire configure to create a new project on Firebase. Add Firebase plugins: bash flutter pub add firebase_plugin_name1 firebase_plugin_name2 ... Run flutterfire configure again after adding all plugins.","title":"2. Firebase Configuration"},{"location":"flutter/new-project-with-firebase/#3-android-setup","text":"","title":"3. Android Setup"},{"location":"flutter/new-project-with-firebase/#update-appbuildgradle","text":"Add these dependencies: dependencies { // Import the Firebase BoM implementation platform('com.google.firebase:firebase-bom:33.2.0') // Add the dependencies for Firebase products implementation 'com.google.firebase:firebase-auth' implementation 'com.google.firebase:firebase-firestore' implementation 'com.google.firebase:firebase-storage' implementation 'com.google.firebase:firebase-analytics' // For Google Sign-In implementation 'com.google.android.gms:play-services-auth:20.7.0' // Add other Firebase products as needed } Sync the gradle in Android Studio after adding dependencies.","title":"Update app/build.gradle"},{"location":"flutter/new-project-with-firebase/#4-firebase-console-setup","text":"Enable password signin and Google sign-in providers. Add SHA1 and SHA256 keys for Google Sign-In.","title":"4. Firebase Console Setup"},{"location":"flutter/new-project-with-firebase/#generate-release-keystore","text":"In the android folder, run: keytool -genkey -v -keystore encyclopedia-release-key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias encyclopedia","title":"Generate Release Keystore"},{"location":"flutter/new-project-with-firebase/#configure-release-keystore","text":"In app/build.gradle: android { ... signingConfigs { release { keyAlias 'com.initiatehub.encyclopedia' keyPassword 'your-key-password' storeFile file('encyclopedia-release-key.jks') storePassword 'your-keystore-password' } } buildTypes { release { signingConfig signingConfigs.release minifyEnabled false shrinkResources false } } }","title":"Configure Release Keystore"},{"location":"flutter/new-project-with-firebase/#get-signing-report","text":"Run in the android folder: ./gradlew signingReport Add both debug and release SHA1 and SHA256 to Firebase console project settings.","title":"Get Signing Report"},{"location":"flutter/new-project-with-firebase/#5-final-steps","text":"Run flutterfire configure again to pull all Firebase config changes. Copy all auth feature code to the new project. Note: If prompted to upgrade Kotlin version during gradle sync, follow the system instructions.","title":"5. Final Steps"},{"location":"flutter/project-structure/","text":"Project Structure Documentation Introduction to the Project Structure A well-organized project structure is essential for maintaining clean, scalable, and manageable code in a Flutter application. The structure outlined below separates concerns by grouping related files and functionality into logical directories. This approach enhances collaboration among team members, simplifies debugging, and facilitates easier scaling and maintenance of the application as it grows. The structure includes directories like core for foundational elements, shared for reusable UI components, features for feature-specific code, and startup for initialization logic. Each directory has a specific purpose, which helps maintain a clear and logical organization of the codebase. Example Folder Tree lib/ \u2523 core/ // Foundational and configuration elements \u2503 \u2523 config.dart // Application-wide configuration settings \u2503 \u2523 constants.dart // Global constants for UI, styling, etc. \u2503 \u2517 utils/ // General utilities used throughout the app \u2503 \u2517 date_utils.dart // Example utility file \u2523 shared/ // Reusable UI components and shared widgets \u2503 \u2517 widgets/ // Folder for shared/reusable widgets \u2503 \u2523 custom_button.dart // Example of a custom button widget \u2503 \u2523 custom_card.dart // Example of a custom card widget \u2503 \u2517 loading_spinner.dart // Example of a reusable loading spinner \u2523 features/ // Feature-specific modules \u2503 \u2523 auth/ // Authentication feature \u2503 \u2503 \u2523 models/ \u2503 \u2503 \u2503 \u2517 user_model.dart // Data model for user \u2503 \u2503 \u2523 providers/ \u2503 \u2503 \u2503 \u2517 auth_provider.dart // State management for auth \u2503 \u2503 \u2523 screens/ \u2503 \u2503 \u2503 \u2523 forgot_password_screen.dart // Forgot password screen \u2503 \u2503 \u2503 \u2523 login_screen.dart // Login screen \u2503 \u2503 \u2503 \u2517 signup_screen.dart // Signup screen \u2503 \u2503 \u2523 services/ \u2503 \u2503 \u2503 \u2517 auth_service.dart // Service for authentication logic \u2503 \u2503 \u2517 utils/ \u2503 \u2503 \u2523 auth_exception_handler.dart // Handles auth exceptions \u2503 \u2503 \u2517 auth_validators.dart // Validation logic for auth forms \u2503 \u2517 home/ // Home feature \u2503 \u2523 screens/ \u2503 \u2503 \u2517 home_screen.dart // Home screen \u2503 \u2517 widgets/ // Feature-specific widgets \u2503 \u2517 home_banner.dart // Example widget for home screen \u2523 startup/ // Application initialization \u2503 \u2523 app_providers.dart // Setup of app-wide providers and state management \u2503 \u2517 app_router.dart // Configuration of app routes \u2523 firebase_options.dart // Firebase configuration \u2517 main.dart // Main entry point of the application Expanded Explanation of the Structure core/ Purpose : Acts as the backbone of the application, containing critical elements such as global configurations, constants, and utilities that are essential for the overall setup and operation of the app. Contents : Configuration Files : These files, like config.dart , define environment-specific settings that influence how the app behaves across different environments (development, staging, production). Constants : Files like constants.dart hold static values such as colors, padding, and font sizes used throughout the app, promoting consistency and easy modifications. Utilities : Utility files provide helper functions that can be used across the app, improving code reusability and reducing redundancy. shared/ Purpose : Focuses on reusable UI components and design elements that can be utilized across various parts of the app, ensuring a consistent look and feel. Contents : Widgets : Contains reusable components like buttons, cards, and loading spinners that are commonly used throughout the app's UI. By centralizing these widgets, changes can be made in one place and automatically reflected wherever these components are used. features/ Purpose : Organizes the code into self-contained modules, each representing a distinct feature or functionality of the app, such as authentication or home screens. This modular approach simplifies development, testing, and maintenance by isolating features. Contents : Models : Defines data structures related to the feature, such as user_model.dart for user data in the authentication feature. Providers : Contains state management classes specific to the feature, such as auth_provider.dart , to handle state and business logic. Screens : Includes the UI screens for the feature, such as login_screen.dart and signup_screen.dart , ensuring that the feature's UI components are kept together. Services : Implements feature-specific services, like API interactions in auth_service.dart , keeping the feature's logic encapsulated. Utils : Houses utility functions specific to the feature, enhancing modularity and reusability within that context. startup/ Purpose : Manages the application's startup process, including the initialization of providers and setting up routing, ensuring a clean and organized launch sequence. Contents : App Providers : Sets up global state management, such as configuring providers for dependency injection. App Router : Defines the navigation structure, handling route configuration and navigation logic to keep routing centralized and manageable. This structured approach helps maintain a clean, scalable, and organized codebase, making it easier to collaborate, extend functionality, and maintain the application over time.","title":"Project Structure"},{"location":"flutter/project-structure/#project-structure-documentation","text":"","title":"Project Structure Documentation"},{"location":"flutter/project-structure/#introduction-to-the-project-structure","text":"A well-organized project structure is essential for maintaining clean, scalable, and manageable code in a Flutter application. The structure outlined below separates concerns by grouping related files and functionality into logical directories. This approach enhances collaboration among team members, simplifies debugging, and facilitates easier scaling and maintenance of the application as it grows. The structure includes directories like core for foundational elements, shared for reusable UI components, features for feature-specific code, and startup for initialization logic. Each directory has a specific purpose, which helps maintain a clear and logical organization of the codebase.","title":"Introduction to the Project Structure"},{"location":"flutter/project-structure/#example-folder-tree","text":"lib/ \u2523 core/ // Foundational and configuration elements \u2503 \u2523 config.dart // Application-wide configuration settings \u2503 \u2523 constants.dart // Global constants for UI, styling, etc. \u2503 \u2517 utils/ // General utilities used throughout the app \u2503 \u2517 date_utils.dart // Example utility file \u2523 shared/ // Reusable UI components and shared widgets \u2503 \u2517 widgets/ // Folder for shared/reusable widgets \u2503 \u2523 custom_button.dart // Example of a custom button widget \u2503 \u2523 custom_card.dart // Example of a custom card widget \u2503 \u2517 loading_spinner.dart // Example of a reusable loading spinner \u2523 features/ // Feature-specific modules \u2503 \u2523 auth/ // Authentication feature \u2503 \u2503 \u2523 models/ \u2503 \u2503 \u2503 \u2517 user_model.dart // Data model for user \u2503 \u2503 \u2523 providers/ \u2503 \u2503 \u2503 \u2517 auth_provider.dart // State management for auth \u2503 \u2503 \u2523 screens/ \u2503 \u2503 \u2503 \u2523 forgot_password_screen.dart // Forgot password screen \u2503 \u2503 \u2503 \u2523 login_screen.dart // Login screen \u2503 \u2503 \u2503 \u2517 signup_screen.dart // Signup screen \u2503 \u2503 \u2523 services/ \u2503 \u2503 \u2503 \u2517 auth_service.dart // Service for authentication logic \u2503 \u2503 \u2517 utils/ \u2503 \u2503 \u2523 auth_exception_handler.dart // Handles auth exceptions \u2503 \u2503 \u2517 auth_validators.dart // Validation logic for auth forms \u2503 \u2517 home/ // Home feature \u2503 \u2523 screens/ \u2503 \u2503 \u2517 home_screen.dart // Home screen \u2503 \u2517 widgets/ // Feature-specific widgets \u2503 \u2517 home_banner.dart // Example widget for home screen \u2523 startup/ // Application initialization \u2503 \u2523 app_providers.dart // Setup of app-wide providers and state management \u2503 \u2517 app_router.dart // Configuration of app routes \u2523 firebase_options.dart // Firebase configuration \u2517 main.dart // Main entry point of the application","title":"Example Folder Tree"},{"location":"flutter/project-structure/#expanded-explanation-of-the-structure","text":"","title":"Expanded Explanation of the Structure"},{"location":"flutter/project-structure/#core","text":"Purpose : Acts as the backbone of the application, containing critical elements such as global configurations, constants, and utilities that are essential for the overall setup and operation of the app. Contents : Configuration Files : These files, like config.dart , define environment-specific settings that influence how the app behaves across different environments (development, staging, production). Constants : Files like constants.dart hold static values such as colors, padding, and font sizes used throughout the app, promoting consistency and easy modifications. Utilities : Utility files provide helper functions that can be used across the app, improving code reusability and reducing redundancy.","title":"core/"},{"location":"flutter/project-structure/#shared","text":"Purpose : Focuses on reusable UI components and design elements that can be utilized across various parts of the app, ensuring a consistent look and feel. Contents : Widgets : Contains reusable components like buttons, cards, and loading spinners that are commonly used throughout the app's UI. By centralizing these widgets, changes can be made in one place and automatically reflected wherever these components are used.","title":"shared/"},{"location":"flutter/project-structure/#features","text":"Purpose : Organizes the code into self-contained modules, each representing a distinct feature or functionality of the app, such as authentication or home screens. This modular approach simplifies development, testing, and maintenance by isolating features. Contents : Models : Defines data structures related to the feature, such as user_model.dart for user data in the authentication feature. Providers : Contains state management classes specific to the feature, such as auth_provider.dart , to handle state and business logic. Screens : Includes the UI screens for the feature, such as login_screen.dart and signup_screen.dart , ensuring that the feature's UI components are kept together. Services : Implements feature-specific services, like API interactions in auth_service.dart , keeping the feature's logic encapsulated. Utils : Houses utility functions specific to the feature, enhancing modularity and reusability within that context.","title":"features/"},{"location":"flutter/project-structure/#startup","text":"Purpose : Manages the application's startup process, including the initialization of providers and setting up routing, ensuring a clean and organized launch sequence. Contents : App Providers : Sets up global state management, such as configuring providers for dependency injection. App Router : Defines the navigation structure, handling route configuration and navigation logic to keep routing centralized and manageable. This structured approach helps maintain a clean, scalable, and organized codebase, making it easier to collaborate, extend functionality, and maintain the application over time.","title":"startup/"},{"location":"projects/encyclopedia/","text":"Introduction to the Development of the Enhanced Encyclopedia Mobile App Welcome to the development phase of our Enhanced Encyclopedia Mobile App, designed specifically for K-12 students and available on both iOS and Android platforms. This project aims to create a dynamic and interactive learning tool that provides students with a rich, personalized educational experience right at their fingertips. Development Overview Our app will be developed using Flutter, allowing us to maintain a single codebase for both iOS and Android, ensuring a consistent user experience across devices. The app will leverage Firebase as the backend, providing robust, scalable, and secure services that meet the needs of our young audience. Key Technologies and Frameworks Flutter Chosen for its ability to deliver high-performance, visually appealing applications across both iOS and Android with a single codebase. Flutter's rich widget library will help us create an engaging and intuitive user interface tailored to K-12 students. Firebase Integration Firebase Authentication : We'll implement Firebase Auth to handle user authentication, supporting both email/password sign-ins and social sign-ins (e.g., Google, Apple, and other popular platforms). This approach ensures a secure and seamless login experience for students. Firebase Firestore : As our primary database, Firestore will store all dynamic content, user data, progress tracking, and other essential app data. Its real-time synchronization capabilities will provide users with up-to-date content and interactive features. Firebase Storage : Firebase Storage will be utilized for storing and serving static assets, such as images, videos, and audio files. This will enable smooth media delivery and ensure that all content is reliably available across various network conditions. AI-Driven Content Generation and Voice-Over The app will use AI to generate tailored content, adapting to each student's learning pace and preferences. This includes personalized article recommendations, quiz questions, and interactive educational activities. AI-powered voice-over features will provide read-aloud options, enhancing accessibility for early readers and students with learning differences. This feature aims to support auditory learning styles and improve overall engagement. Target Audience The primary audience for our app includes K-12 students, spanning a wide age and education range. Therefore, the app will be designed with flexible content adaptability to meet the varying cognitive and developmental needs of this audience. This includes: Simplified navigation and a user-friendly interface appropriate for younger users. Age-appropriate content filters to ensure safety and relevance. Features that cater to different learning styles, including visual, auditory, and kinesthetic learners. Project Objectives and Next Steps Our immediate objectives include: Setting Up the Backend : Configuring Firebase services, including setting up Firestore collections and documents, configuring Firebase Auth for multi-method sign-in options, and organizing Firebase Storage for multimedia assets. Building the Core Features : Starting with essential features like content display, interactive quizzes, progress tracking, and personalized recommendations. These will form the backbone of the app's value proposition to users. Implementing AI Capabilities : Integrating AI for content generation and voice-over functionalities, ensuring these features are seamlessly incorporated into the user experience. Testing and Iteration : Rigorous testing across devices to ensure the app meets performance and usability standards for both iOS and Android. Feedback loops with educators and students will guide iterative improvements. This development approach will ensure we build a robust, engaging, and educationally valuable app that supports diverse learning journeys. Our commitment is to provide a reliable, scalable solution that grows with its users, delivering an enriching educational experience for K-12 students. By leveraging cutting-edge technologies and educational best practices, we aim to create an encyclopedia app that not only informs but inspires a lifelong love of learning.","title":"Overview"},{"location":"projects/encyclopedia/#introduction-to-the-development-of-the-enhanced-encyclopedia-mobile-app","text":"Welcome to the development phase of our Enhanced Encyclopedia Mobile App, designed specifically for K-12 students and available on both iOS and Android platforms. This project aims to create a dynamic and interactive learning tool that provides students with a rich, personalized educational experience right at their fingertips.","title":"Introduction to the Development of the Enhanced Encyclopedia Mobile App"},{"location":"projects/encyclopedia/#development-overview","text":"Our app will be developed using Flutter, allowing us to maintain a single codebase for both iOS and Android, ensuring a consistent user experience across devices. The app will leverage Firebase as the backend, providing robust, scalable, and secure services that meet the needs of our young audience.","title":"Development Overview"},{"location":"projects/encyclopedia/#key-technologies-and-frameworks","text":"","title":"Key Technologies and Frameworks"},{"location":"projects/encyclopedia/#flutter","text":"Chosen for its ability to deliver high-performance, visually appealing applications across both iOS and Android with a single codebase. Flutter's rich widget library will help us create an engaging and intuitive user interface tailored to K-12 students.","title":"Flutter"},{"location":"projects/encyclopedia/#firebase-integration","text":"Firebase Authentication : We'll implement Firebase Auth to handle user authentication, supporting both email/password sign-ins and social sign-ins (e.g., Google, Apple, and other popular platforms). This approach ensures a secure and seamless login experience for students. Firebase Firestore : As our primary database, Firestore will store all dynamic content, user data, progress tracking, and other essential app data. Its real-time synchronization capabilities will provide users with up-to-date content and interactive features. Firebase Storage : Firebase Storage will be utilized for storing and serving static assets, such as images, videos, and audio files. This will enable smooth media delivery and ensure that all content is reliably available across various network conditions.","title":"Firebase Integration"},{"location":"projects/encyclopedia/#ai-driven-content-generation-and-voice-over","text":"The app will use AI to generate tailored content, adapting to each student's learning pace and preferences. This includes personalized article recommendations, quiz questions, and interactive educational activities. AI-powered voice-over features will provide read-aloud options, enhancing accessibility for early readers and students with learning differences. This feature aims to support auditory learning styles and improve overall engagement.","title":"AI-Driven Content Generation and Voice-Over"},{"location":"projects/encyclopedia/#target-audience","text":"The primary audience for our app includes K-12 students, spanning a wide age and education range. Therefore, the app will be designed with flexible content adaptability to meet the varying cognitive and developmental needs of this audience. This includes: Simplified navigation and a user-friendly interface appropriate for younger users. Age-appropriate content filters to ensure safety and relevance. Features that cater to different learning styles, including visual, auditory, and kinesthetic learners.","title":"Target Audience"},{"location":"projects/encyclopedia/#project-objectives-and-next-steps","text":"Our immediate objectives include: Setting Up the Backend : Configuring Firebase services, including setting up Firestore collections and documents, configuring Firebase Auth for multi-method sign-in options, and organizing Firebase Storage for multimedia assets. Building the Core Features : Starting with essential features like content display, interactive quizzes, progress tracking, and personalized recommendations. These will form the backbone of the app's value proposition to users. Implementing AI Capabilities : Integrating AI for content generation and voice-over functionalities, ensuring these features are seamlessly incorporated into the user experience. Testing and Iteration : Rigorous testing across devices to ensure the app meets performance and usability standards for both iOS and Android. Feedback loops with educators and students will guide iterative improvements. This development approach will ensure we build a robust, engaging, and educationally valuable app that supports diverse learning journeys. Our commitment is to provide a reliable, scalable solution that grows with its users, delivering an enriching educational experience for K-12 students. By leveraging cutting-edge technologies and educational best practices, we aim to create an encyclopedia app that not only informs but inspires a lifelong love of learning.","title":"Project Objectives and Next Steps"},{"location":"projects/encyclopedia/features-wall/","text":"Enhanced Encyclopedia Mobile App Features 1. Smart Content Adaptation Utilize AI to dynamically adjust content complexity based on user interactions and reading speed Implement a \"grow with me\" feature that gradually introduces more advanced concepts as the user progresses 2. Rich Multimedia Content Incorporate interactive 3D models for scientific and historical concepts Add a \"Story Mode\" feature that presents historical events or scientific processes as engaging narratives 3. Personalized Learning Ecosystem Implement spaced repetition algorithms to reinforce learned concepts over time Offer AI-powered study recommendations based on the user's learning style and interests 4. Engaging and Inclusive Interface Implement a customizable color scheme with options for different themes (e.g., nature, space, history) Use dyslexia-friendly fonts and high-contrast mode for better accessibility Create diverse, culturally representative mascots to guide users through the app 5. Interactive Home Screen Design a customizable dashboard where users can pin favorite topics or current areas of study Include a \"Topic of the Day\" feature with rotating subjects to encourage diverse learning 6. Gamified Learning Experience Create an \"Explorer's Journey\" with quests and challenges across different subject areas Introduce peer competitions and leaderboards for quiz scores and learning streaks 7. Accessibility and Language Support Provide real-time language translation for article content Include sign language video explanations for key concepts 8. Comprehensive Progress Tracking Visualize learning progress with interactive knowledge maps Generate detailed reports on areas of strength and opportunities for improvement 9. Integration with Educational Standards Align content with national and international curriculum standards Provide tools for teachers to create custom curricula and track class progress 10. Adaptive Assessment Use machine learning to generate personalized quizzes that adapt to the user's knowledge level Provide instant, constructive feedback on quiz performance with tailored learning recommendations 11. Offline and Low-Bandwidth Options Compress content for efficient offline storage Offer text-only versions of articles for low-bandwidth situations 12. Cross-Platform Synchronization Enable seamless transition between mobile devices, tablets, and desktop computers Integrate with popular learning management systems used in schools 13. Parental and Educator Involvement Create a companion app for parents and teachers to monitor progress and set learning goals Facilitate parent-teacher communication through in-app messaging and progress sharing 14. Collaborative Learning Features Create virtual study rooms where friends can learn together in real-time Implement a \"Peer Tutor\" system where older students can earn rewards for helping younger ones 15. Gamified Research Skills Teach information literacy through interactive lessons on fact-checking and source evaluation Reward users for citing sources and cross-referencing information","title":"Features Wall"},{"location":"projects/encyclopedia/features-wall/#enhanced-encyclopedia-mobile-app-features","text":"","title":"Enhanced Encyclopedia Mobile App Features"},{"location":"projects/encyclopedia/features-wall/#1-smart-content-adaptation","text":"Utilize AI to dynamically adjust content complexity based on user interactions and reading speed Implement a \"grow with me\" feature that gradually introduces more advanced concepts as the user progresses","title":"1. Smart Content Adaptation"},{"location":"projects/encyclopedia/features-wall/#2-rich-multimedia-content","text":"Incorporate interactive 3D models for scientific and historical concepts Add a \"Story Mode\" feature that presents historical events or scientific processes as engaging narratives","title":"2. Rich Multimedia Content"},{"location":"projects/encyclopedia/features-wall/#3-personalized-learning-ecosystem","text":"Implement spaced repetition algorithms to reinforce learned concepts over time Offer AI-powered study recommendations based on the user's learning style and interests","title":"3. Personalized Learning Ecosystem"},{"location":"projects/encyclopedia/features-wall/#4-engaging-and-inclusive-interface","text":"Implement a customizable color scheme with options for different themes (e.g., nature, space, history) Use dyslexia-friendly fonts and high-contrast mode for better accessibility Create diverse, culturally representative mascots to guide users through the app","title":"4. Engaging and Inclusive Interface"},{"location":"projects/encyclopedia/features-wall/#5-interactive-home-screen","text":"Design a customizable dashboard where users can pin favorite topics or current areas of study Include a \"Topic of the Day\" feature with rotating subjects to encourage diverse learning","title":"5. Interactive Home Screen"},{"location":"projects/encyclopedia/features-wall/#6-gamified-learning-experience","text":"Create an \"Explorer's Journey\" with quests and challenges across different subject areas Introduce peer competitions and leaderboards for quiz scores and learning streaks","title":"6. Gamified Learning Experience"},{"location":"projects/encyclopedia/features-wall/#7-accessibility-and-language-support","text":"Provide real-time language translation for article content Include sign language video explanations for key concepts","title":"7. Accessibility and Language Support"},{"location":"projects/encyclopedia/features-wall/#8-comprehensive-progress-tracking","text":"Visualize learning progress with interactive knowledge maps Generate detailed reports on areas of strength and opportunities for improvement","title":"8. Comprehensive Progress Tracking"},{"location":"projects/encyclopedia/features-wall/#9-integration-with-educational-standards","text":"Align content with national and international curriculum standards Provide tools for teachers to create custom curricula and track class progress","title":"9. Integration with Educational Standards"},{"location":"projects/encyclopedia/features-wall/#10-adaptive-assessment","text":"Use machine learning to generate personalized quizzes that adapt to the user's knowledge level Provide instant, constructive feedback on quiz performance with tailored learning recommendations","title":"10. Adaptive Assessment"},{"location":"projects/encyclopedia/features-wall/#11-offline-and-low-bandwidth-options","text":"Compress content for efficient offline storage Offer text-only versions of articles for low-bandwidth situations","title":"11. Offline and Low-Bandwidth Options"},{"location":"projects/encyclopedia/features-wall/#12-cross-platform-synchronization","text":"Enable seamless transition between mobile devices, tablets, and desktop computers Integrate with popular learning management systems used in schools","title":"12. Cross-Platform Synchronization"},{"location":"projects/encyclopedia/features-wall/#13-parental-and-educator-involvement","text":"Create a companion app for parents and teachers to monitor progress and set learning goals Facilitate parent-teacher communication through in-app messaging and progress sharing","title":"13. Parental and Educator Involvement"},{"location":"projects/encyclopedia/features-wall/#14-collaborative-learning-features","text":"Create virtual study rooms where friends can learn together in real-time Implement a \"Peer Tutor\" system where older students can earn rewards for helping younger ones","title":"14. Collaborative Learning Features"},{"location":"projects/encyclopedia/features-wall/#15-gamified-research-skills","text":"Teach information literacy through interactive lessons on fact-checking and source evaluation Reward users for citing sources and cross-referencing information","title":"15. Gamified Research Skills"},{"location":"strapi/strapi-deploy-guide/","text":"Deploying Strapi with PostgreSQL on a VPS Using Docker Compose This guide outlines the steps to deploy a Strapi application with PostgreSQL on a VPS using Docker Compose. We'll cover setting up your environment, pushing the Docker image to Docker Hub, and deploying on your VPS. Prerequisites Before you begin, ensure you have: Access to Your VPS: Ensure you have SSH access to your VPS with your user credentials and IP address. Connecting to the VPS Using SSH: Use the following command to connect to your VPS. Replace user with your VPS username and your_vps_ip with the IP address of your VPS: bash ssh user@your_vps_ip Install Docker on Your VPS: After connecting to your VPS, install Docker by running: bash curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh This script will automatically install the latest version of Docker on your VPS. Install Docker Compose: Install Docker Compose using the following command: bash sudo apt-get install docker-compose -y This command installs Docker Compose, which is required to manage multi-container Docker applications like Strapi with PostgreSQL. Verify Installations: Check Docker version to ensure it's installed correctly: bash docker --version Check Docker Compose version: bash docker-compose --version Step 1: Create and Push Docker Image to Docker Hub In this step, we will first create the Strapi Docker image using a Dockerfile, then push the image to a private Docker Hub repository. 1.1: Create the Strapi Docker Image Using a Dockerfile Navigate to Your Strapi Project Directory: Open your terminal and navigate to the root of your Strapi project where your Dockerfile is located: bash cd /path/to/your-strapi-project Create a Dockerfile in the Root of Your Project: Ensure that your Dockerfile is properly set up in the root of your Strapi project. Here\u2019s an example Dockerfile: ```yaml # Use Node.js 20 as the base image FROM node:20 # Set the working directory inside the container WORKDIR /app # Copy package.json and package-lock.json first for caching layer COPY package*.json ./ # Install dependencies RUN npm install # Copy the rest of the application code COPY . . # Build the Strapi application RUN npm run build # Expose the port Strapi will run on EXPOSE 1337 # Start the Strapi application CMD [\"npm\", \"run\", \"start\"] ``` Build the Docker Image: Run the following command to build the Docker image from the Dockerfile: bash docker build -t your-dockerhub-username/strapi-app:latest . This command builds the Docker image and tags it as your-dockerhub-username/strapi-app:latest . Adjust the tag name according to your preference. 1.2: Push Docker Image to Docker Hub Log in to Docker Hub: Use the following command to log in to Docker Hub: bash docker login Enter your Docker Hub username and password when prompted. Create a Private Repository on Docker Hub: Go to Docker Hub and log in to your account. Click on the \u201cRepositories\u201d tab and then click \u201cCreate Repository.\u201d Set the repository name (e.g., strapi-app ), ensure the \"Private\" option is selected, and click \"Create.\" Tag Your Docker Image for Docker Hub: Tag your locally built Docker image to match your Docker Hub repository: bash docker tag your-dockerhub-username/strapi-app:latest your-dockerhub-username/strapi-app:latest Replace your-dockerhub-username with your actual Docker Hub username. Push the Image to Docker Hub: Push the tagged image to your private repository on Docker Hub: bash docker push your-dockerhub-username/strapi-app:latest Step 2: Prepare Your VPS Connect to your VPS: bash ssh user@your_vps_ip Replace user with your VPS username and your_vps_ip with the IP address of your VPS. Install Docker and Docker Compose: ```bash # Install Docker curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh # Install Docker Compose sudo apt-get install docker-compose -y ``` Create a directory for your project: bash sudo mkdir -p /srv/strapi sudo chown $USER:$USER /srv/strapi cd /srv/strapi Step 3: Update .env File Ensure your .env file contains the correct environment variables: HOST=0.0.0.0 PORT=1337 APP_KEYS= # Auto generated by strapi API_TOKEN_SALT= # Auto generated by strapi ADMIN_JWT_SECRET= # Auto generated by strapi TRANSFER_TOKEN_SALT= # Auto generated by strapi JWT_SECRET= # Auto generated by strapi DATABASE_CLIENT=postgres DATABASE_HOST=postgres DATABASE_PORT=5432 DATABASE_NAME=strapi_db DATABASE_USERNAME=strapi_user DATABASE_PASSWORD=your_password # Replace with your actual password DATABASE_SSL=false NODE_ENV=production Step 4: Create and Configure Docker Compose File Ensure your docker-compose.yml is configured as follows: services: strapi: image: your-dockerhub-username/strapi-app:latest # Replace with your actual image name container_name: strapi-app env_file: - .env # Load environment variables from the .env file ports: - \"1337:1337\" # Map host port 1337 to container port 1337 depends_on: - postgres # Ensures the postgres service is started before strapi volumes: - ./uploads:/app/public/uploads # Persist media uploads to the host postgres: image: postgres:16.4 container_name: strapi-postgres environment: POSTGRES_USER: ${DATABASE_USERNAME} # Use variables from .env POSTGRES_PASSWORD: ${DATABASE_PASSWORD} POSTGRES_DB: ${DATABASE_NAME} volumes: - ./pgdata:/var/lib/postgresql/data # Persist PostgreSQL data to the host ports: - \"5432:5432\" # Map host port 5432 to container port 5432 Step 5: Copy Your Docker Compose and .env Files to the VPS: Open a New Terminal on Your Local Machine: In a new terminal on your local machine (not the VPS), use the scp command to copy the necessary files to your VPS: scp docker-compose.yml .env user@your_vps_ip:/srv/strapi Step 6: Deploy Strapi with Docker Compose Start the Docker Compose services: bash cd /srv/strapi docker-compose up -d Verify the deployment: Check the status of the containers: bash docker-compose ps View logs to ensure everything is running correctly: bash docker-compose logs -f Access Strapi: Open your browser and go to http://your_vps_ip:1337/admin to access the Strapi admin panel.","title":"Deploy Guide"},{"location":"strapi/strapi-deploy-guide/#deploying-strapi-with-postgresql-on-a-vps-using-docker-compose","text":"This guide outlines the steps to deploy a Strapi application with PostgreSQL on a VPS using Docker Compose. We'll cover setting up your environment, pushing the Docker image to Docker Hub, and deploying on your VPS.","title":"Deploying Strapi with PostgreSQL on a VPS Using Docker Compose"},{"location":"strapi/strapi-deploy-guide/#prerequisites","text":"Before you begin, ensure you have: Access to Your VPS: Ensure you have SSH access to your VPS with your user credentials and IP address. Connecting to the VPS Using SSH: Use the following command to connect to your VPS. Replace user with your VPS username and your_vps_ip with the IP address of your VPS: bash ssh user@your_vps_ip Install Docker on Your VPS: After connecting to your VPS, install Docker by running: bash curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh This script will automatically install the latest version of Docker on your VPS. Install Docker Compose: Install Docker Compose using the following command: bash sudo apt-get install docker-compose -y This command installs Docker Compose, which is required to manage multi-container Docker applications like Strapi with PostgreSQL. Verify Installations: Check Docker version to ensure it's installed correctly: bash docker --version Check Docker Compose version: bash docker-compose --version","title":"Prerequisites"},{"location":"strapi/strapi-deploy-guide/#step-1-create-and-push-docker-image-to-docker-hub","text":"In this step, we will first create the Strapi Docker image using a Dockerfile, then push the image to a private Docker Hub repository.","title":"Step 1: Create and Push Docker Image to Docker Hub"},{"location":"strapi/strapi-deploy-guide/#11-create-the-strapi-docker-image-using-a-dockerfile","text":"Navigate to Your Strapi Project Directory: Open your terminal and navigate to the root of your Strapi project where your Dockerfile is located: bash cd /path/to/your-strapi-project Create a Dockerfile in the Root of Your Project: Ensure that your Dockerfile is properly set up in the root of your Strapi project. Here\u2019s an example Dockerfile: ```yaml # Use Node.js 20 as the base image FROM node:20 # Set the working directory inside the container WORKDIR /app # Copy package.json and package-lock.json first for caching layer COPY package*.json ./ # Install dependencies RUN npm install # Copy the rest of the application code COPY . . # Build the Strapi application RUN npm run build # Expose the port Strapi will run on EXPOSE 1337 # Start the Strapi application CMD [\"npm\", \"run\", \"start\"] ``` Build the Docker Image: Run the following command to build the Docker image from the Dockerfile: bash docker build -t your-dockerhub-username/strapi-app:latest . This command builds the Docker image and tags it as your-dockerhub-username/strapi-app:latest . Adjust the tag name according to your preference.","title":"1.1: Create the Strapi Docker Image Using a Dockerfile"},{"location":"strapi/strapi-deploy-guide/#12-push-docker-image-to-docker-hub","text":"Log in to Docker Hub: Use the following command to log in to Docker Hub: bash docker login Enter your Docker Hub username and password when prompted. Create a Private Repository on Docker Hub: Go to Docker Hub and log in to your account. Click on the \u201cRepositories\u201d tab and then click \u201cCreate Repository.\u201d Set the repository name (e.g., strapi-app ), ensure the \"Private\" option is selected, and click \"Create.\" Tag Your Docker Image for Docker Hub: Tag your locally built Docker image to match your Docker Hub repository: bash docker tag your-dockerhub-username/strapi-app:latest your-dockerhub-username/strapi-app:latest Replace your-dockerhub-username with your actual Docker Hub username. Push the Image to Docker Hub: Push the tagged image to your private repository on Docker Hub: bash docker push your-dockerhub-username/strapi-app:latest","title":"1.2: Push Docker Image to Docker Hub"},{"location":"strapi/strapi-deploy-guide/#step-2-prepare-your-vps","text":"Connect to your VPS: bash ssh user@your_vps_ip Replace user with your VPS username and your_vps_ip with the IP address of your VPS. Install Docker and Docker Compose: ```bash # Install Docker curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh # Install Docker Compose sudo apt-get install docker-compose -y ``` Create a directory for your project: bash sudo mkdir -p /srv/strapi sudo chown $USER:$USER /srv/strapi cd /srv/strapi","title":"Step 2: Prepare Your VPS"},{"location":"strapi/strapi-deploy-guide/#step-3-update-env-file","text":"Ensure your .env file contains the correct environment variables: HOST=0.0.0.0 PORT=1337 APP_KEYS= # Auto generated by strapi API_TOKEN_SALT= # Auto generated by strapi ADMIN_JWT_SECRET= # Auto generated by strapi TRANSFER_TOKEN_SALT= # Auto generated by strapi JWT_SECRET= # Auto generated by strapi DATABASE_CLIENT=postgres DATABASE_HOST=postgres DATABASE_PORT=5432 DATABASE_NAME=strapi_db DATABASE_USERNAME=strapi_user DATABASE_PASSWORD=your_password # Replace with your actual password DATABASE_SSL=false NODE_ENV=production","title":"Step 3: Update .env File"},{"location":"strapi/strapi-deploy-guide/#step-4-create-and-configure-docker-compose-file","text":"Ensure your docker-compose.yml is configured as follows: services: strapi: image: your-dockerhub-username/strapi-app:latest # Replace with your actual image name container_name: strapi-app env_file: - .env # Load environment variables from the .env file ports: - \"1337:1337\" # Map host port 1337 to container port 1337 depends_on: - postgres # Ensures the postgres service is started before strapi volumes: - ./uploads:/app/public/uploads # Persist media uploads to the host postgres: image: postgres:16.4 container_name: strapi-postgres environment: POSTGRES_USER: ${DATABASE_USERNAME} # Use variables from .env POSTGRES_PASSWORD: ${DATABASE_PASSWORD} POSTGRES_DB: ${DATABASE_NAME} volumes: - ./pgdata:/var/lib/postgresql/data # Persist PostgreSQL data to the host ports: - \"5432:5432\" # Map host port 5432 to container port 5432","title":"Step 4: Create and Configure Docker Compose File"},{"location":"strapi/strapi-deploy-guide/#step-5-copy-your-docker-compose-and-env-files-to-the-vps","text":"Open a New Terminal on Your Local Machine: In a new terminal on your local machine (not the VPS), use the scp command to copy the necessary files to your VPS: scp docker-compose.yml .env user@your_vps_ip:/srv/strapi","title":"Step 5: Copy Your Docker Compose and .env Files to the VPS:"},{"location":"strapi/strapi-deploy-guide/#step-6-deploy-strapi-with-docker-compose","text":"Start the Docker Compose services: bash cd /srv/strapi docker-compose up -d Verify the deployment: Check the status of the containers: bash docker-compose ps View logs to ensure everything is running correctly: bash docker-compose logs -f Access Strapi: Open your browser and go to http://your_vps_ip:1337/admin to access the Strapi admin panel.","title":"Step 6: Deploy Strapi with Docker Compose"}]}